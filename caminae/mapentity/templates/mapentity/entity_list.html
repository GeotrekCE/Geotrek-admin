{% extends "mapentity/base.html" %}
{% load i18n leaflet_tags field_verbose_name land %}

{% block nav-list %}active{% endblock nav-list %}

{% block mainmap %}
    {% leaflet_map "mainmap" %}
{% endblock mainmap %}

{% block mainlist %}
    {# ids: bbox_cities bbox_districts #}
    {% combobox_bbox_land %}

    <form id="mainfilter" action="{{ datatables_ajax_url }}" class="well form-inline">
        {{ filterform.form.as_p }}
        <input id="reset" type="reset" class="btn" />
        <a id="filter" class="btn btn-primary"><i class="icon-search icon-white"></i> {% trans "Filter" %}</a>
    </form>

    <table id="objects-list" class="table table-striped table-bordered">
        <thead>
            <tr>
                {% for field in columns %}
                <th>{{ model|verbose:field }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>

    <div id="list-download-toolbar">
        <p>
            <i class="icon-download-alt"></i> 
            Exporter la liste
            <button class="btn btn-mini" name="csv" >CSV</button>
            <button class="btn btn-mini" name="shp" >ShapeFile</button>
            <button class="btn btn-mini" name="gpx" >GPX</button>
        </p>
    </div>

{% endblock mainlist %}

{% block extrabody %}
    {{ block.super }}

    <script type="text/javascript">

        L.Control.Screenshot = L.Control.extend({
            includes: L.Mixin.Events,
            options: {
                position: 'topleft',
                title: '{% trans "Save map as image" %}',
            },
            
            screenshot: function () {
                this.fire('trigger');
            },

            onAdd: function(map) {
                this.map = map;
                this._container = L.DomUtil.create('div', 'leaflet-control-zoom');
                var link = L.DomUtil.create('a', 'leaflet-control-zoom-out', this._container);
                link.href = '#';
                link.title = this.options.title;

                L.DomEvent
                    .addListener(link, 'click', L.DomEvent.stopPropagation)
                    .addListener(link, 'click', L.DomEvent.preventDefault)
                    .addListener(link, 'click', this.screenshot, this);
                return this._container;
            }
        });

        function mainmapInit(mainmap, bounds) {
            mainmap.removeControl(mainmap.attributionControl);
            mainmap.doubleClickZoom.disable();
            
            {% if DEBUG %}
            mainmap.on('viewreset moveend', function () {
                var n = objectsLayer.search(mainmap.getBounds()).length;
                objectsLayer.fire('info', {info : n + ' objects shown'});
            });
            mainmap.addControl(new L.Control.Information());
            {% endif %}

            mainmap.addControl(new L.Control.Measurement());
            
            // Always show the path layer, except if model is path
            // TODO: this is not supposed to be in mapentity --> caminae.common
            if ('{{ model.get_layer_url }}' != '{% url core:path_layer %}') {
                var paths = new MapEntity.ObjectsLayer(null, {
                    indexing: false,
                    style: { clickable:false, weight:2, color:'{{ LAYERCOLOR_PATHS }}'}
                });
                paths.addTo(mainmap)
                paths.load('{% url core:path_layer %}');
                mainmap.layerscontrol.addOverlay(paths, '{% trans "Trails" %}');
            }
            // Add land layers (TODO--> caminae.common)
            var landLayers = [{url:'{% url land:district_layer %}', name: '{% trans "District" %}'},
                              {url:'{% url land:city_layer %}', name: '{% trans "City" %}'},
                              {url:'{% url land:restrictedarea_layer %}', name: '{% trans "Restricted Area" %}'}];
            for (var i=0; i<landLayers.length; i++) {
                var landLayer = landLayers[i];
                var layer = new MapEntity.ObjectsLayer(null, {
                    indexing: false,
                    style: { clickable:false, weight:4, opacity: 0.3, fillOpacity: 0.0, color:'{{ LAYERCOLOR_LAND }}'}
                });
                layer.addTo(mainmap)
                layer.load(landLayer.url);
                mainmap.layerscontrol.addOverlay(layer, landLayer.name);
            }
            
            var getUrl = function (properties, layer) {
                //TODO use nice JS url rewriting
                return "{{ model.get_generic_detail_url }}".replace('0', properties.pk);
            };
            
            var objectsLayer = new MapEntity.ObjectsLayer(null, {
                objectUrl: getUrl,
                style: {opacity: 1.0, fillOpacity:0.7, color: '{{ LAYERCOLOR_OTHERS }}'}
            });
            mainmap.addLayer(objectsLayer);
            mainmap.layerscontrol.addOverlay(objectsLayer, '{{ objectsname|slugify|title }}');
            objectsLayer.load("{{ model.get_layer_url }}");

            // init ajax list
            var dt = initAjaxList(mainmap, objectsLayer);

            MapEntity.Context.restoreFullContext(mainmap, '#mainfilter', dt, '{{ objectsname }}');
            $(window).unload(function () {
                MapEntity.Context.saveFullContext(mainmap, '#mainfilter', dt);
            });
            var screenshot = new L.Control.Screenshot()
            screenshot.on('trigger', function () {
                var fullContext = MapEntity.Context.serializeFullContext(mainmap, '#mainfilter', dt);
                // Hack to download response attachment in Ajax
                $('<form action="{% url mapentity:map_screenshot %}" method="post">' + 
                '<textarea name="printcontext">' + fullContext + '</textarea>' + 
                '</form>').appendTo('body').submit().remove();
            });
            mainmap.addControl(screenshot);
            
            $('#filter').click();

            $('#bbox_cities, #bbox_districts').on('change', function() {
                if ($(this).val()) {
                    var bbox = $.map($(this).val().split(','), parseFloat); // minx,miny,maxx,maxy
                    map.fitBounds([ [bbox[1], bbox[0]], [bbox[3], bbox[2]] ]);
                }
            });
        }

        /* Table initialisation */
        function initAjaxList(map, objectsLayer) {

            var filterform = $('#mainfilter')
              , submitbutton = $('#filter')
              , resetbutton = $('#reset')
              , ajax_list = $('#objects-list')
              , results_panel = document.getElementById('results-panel')
            ;

            var selectorOnce = (function() {
                var current = { 'pk': null, 'row': null };

                function toggleSelectRow($prevRow, $nextRow) {
                    function nextRowAnim() {
                        if ($nextRow) {
                            $nextRow.hide('fast')
                                    .show('fast', function() { $nextRow.addClass('selected-row'); });
                        }
                    }

                    if ($prevRow) {
                        $prevRow.hide('fast', function() { $prevRow.removeClass('selected-row'); })
                                .show('fast', nextRowAnim);
                    } else {
                        nextRowAnim();
                    }
                }

                function toggleSelectObject(pk, on) {
                    on = on === undefined ? true : on;
                    objectsLayer.select(pk, on);
                };

                return {
                    'select': function(pk, row) {
                        // Click on already selected => unselect
                        if (pk == current.pk) {
                            pk = null, row = null;
                        }

                        var prev = current;
                        current = {'pk': pk, 'row': row}

                        toggleSelectRow(prev.row, row);

                        if (prev.pk && prev.row) {
                            toggleSelectObject(prev.pk, false);
                        }
                        if (row && pk) {
                            toggleSelectObject(pk, true);
                        }
                    }
                };
            })();


            // initialize data table
            var dt = JQDataTable.init(
                  ajax_list
                , null // no load at startup
                , {
                    // Hide pk
                    "aoColumnDefs": [ { "bVisible": false, "aTargets": [ 0 ] } ],
                    "fnCreatedRow": function(nRow, aData, iDataIndex ) {
                        var pk = aData[0];
                        $(nRow).hover(function(){
                            objectsLayer.highlight(pk);
                        },
                        function(){
                            objectsLayer.highlight(pk, false);
                        });

                        // select from row
                        $(nRow).click(function() {
                            selectorOnce.select(pk, $(nRow));
                        });
                        $(nRow).dblclick(function() {
                            objectsLayer.jumpTo(pk);
                        });
                    },
                    "sDom": "<'row-fluid'<'span6'i><'span6'f>r>t<'row-fluid'<'span6'l><'span6'p>>",
                    aaData: [],
                    iDeferLoading: 0
                }
            );

            objectsLayer.on('click', function(e) {
                var search_pk = e.layer.properties.pk;
                JQDataTable.goToPage(dt, function pk_equals(row) {
                    return row[0] === search_pk;
                }, function($row) {
                    selectorOnce.select(search_pk, $row);
                });
            });


            // Hardcore customizations
            $('li.next a').html($('li.next a').html().replace('Next', ''));
            $('li.prev a').html($('li.prev a').html().replace('Previous', ''));

            // on JSON load, return the json used by dataTable
            // Update also the map given the layer's pk
            var extract_data_and_pks = function(data, type, callback_args) {
                callback_args.map_obj_pk = data.map_obj_pk;
                return data.aaData;
            }

            function ajaxTrigger(cb) {
                var spinner = new Spinner().spin(results_panel);

                var url = filterform.attr("action") + '?' + filterform.serialize()

                dt.fnReloadAjax(url, extract_data_and_pks, function() {
                    spinner.stop();
                    // Show and save number of results
                    MapEntity.showNumberSearchResults(dt.fnSettings().fnRecordsTotal());
                    cb.apply(cb, arguments);
                });

                return false;
            }

            // Trigger a call to the format url
            $('#list-download-toolbar button').on('click', function exportList() {
                var format = $(this).attr('name');
                var url = "{{ model.get_format_list_url }}" + '?' +
                          filterform.serialize() + '&format=' + format;

                document.location = url;

                return false;
            });

            // Store the map bounds as WKT in the bbox field
            function storeBoundsToField($field, bounds) {
                var rect = new L.Rectangle([bounds._northEast, bounds._southWest]);
                $field.val(MapEntity.getWKT(rect));
            }

            var initial_map_bounds = map.getBounds();
            var bbox_field = $('#id_bbox');
            var storeCurrentMapBoundsToField = function() { storeBoundsToField(bbox_field, map.getBounds()); };

            // Restore initial map bounds on trigger
            submitbutton.click(ajaxMapObjectsUpdateOnly);
            resetbutton.click(function() {
                MapEntity.resetForm(filterform);
                mapBoundsUpdateNoListen(initial_map_bounds, listenMapBoundsUpdate);
                ajaxMapObjectsUpdateOnly();
                return false;
            });

            // Updates map bounds if necessary (return a boolean if bounds were updated)
            // Unregistering specific callback to avoid triggering ajax request
            function mapBoundsUpdateNoListen(new_bounds, cb) {
                // no need to update if bounds are equals
                if (map.getBounds().equals(new_bounds))
                    return false;

                // deactivate/reactivate listener to trigger our own callback
                cb(false);
                map.fitBounds(new_bounds);
                cb(true);
                return true;
            }

            function ajaxMapObjectsUpdateOnly() {
                storeCurrentMapBoundsToField();
                ajaxTrigger(function(oSettings, callback_args) {
                    objectsLayer.updateFromPks(callback_args.map_obj_pk);
                });
            }

            function ajaxMapBoundsUpdateOnly() {
                storeCurrentMapBoundsToField();
                ajaxTrigger(function(){});
            };

            function listenMapBoundsUpdate(on) {
                on = on === undefined ? true: on;
                map[on ? 'on': 'off']('moveend', ajaxMapBoundsUpdateOnly);
            }

            listenMapBoundsUpdate(true);
            
            return dt;
        };
    </script>

{% endblock extrabody %}
